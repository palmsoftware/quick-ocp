name: 'Quick OCP'
description: 'Quickly deploy an OpenShift cluster on Github Actions hosted runners'
inputs:
  ocpPullSecret:
    description: 'Pull secret for OpenShift Local'
    required: true
  crcMemory:
    description: 'Memory Allocation for OpenShift Local'
    required: false
    default: '10752'
  crcCpu:
    description: 'CPU Allocation for OpenShift Local'
    required: false
    default: '4'
  enableTelemetry:
    description: 'Enable telemetry for OpenShift Local'
    required: false
    default: 'yes'
  crcDiskSize:
    description: 'Disk size for OpenShift Local'
    required: false
    default: '35'
  bundleCache:
    description: 'Cache the crc bundles for faster startup'
    required: false
    default: 'false'
  waitForOperatorsReady:
    description: 'Wait for all operators to be ready'
    required: false
    default: 'false'
  desiredOCPVersion:
    description: 'OpenShift version to deploy'
    required: false
    default: 'latest'

runs:
  using: 'composite'
  steps:

    - name: Set CRC version variable
      id: set_crc_version
      shell: bash
      run: |
        echo "Desired OCP Version: ${{ inputs.desiredOCPVersion }}"
        if [ "${{ inputs.desiredOCPVersion }}" = "latest" ]; then
          echo "crc_version=latest" | tee "$GITHUB_OUTPUT"
        else
          # Only allow OCP versions 4.17 and above
          if [[ ! "${{ inputs.desiredOCPVersion }}" =~ ^4\.(1[7-9]|[2-9][0-9])$ ]] && [[ "${{ inputs.desiredOCPVersion }}" != "latest" ]]; then
            echo "[ERROR] Only OpenShift versions 4.17 and above are supported in this action." >&2
            exit 1
          fi
          echo "Fetching CRC version for OCP ${{ inputs.desiredOCPVersion }}..."
          CRC_VERSION=$("${{ github.action_path }}/scripts/fetch-ocp-crc-version.sh" "${{ inputs.desiredOCPVersion }}")
          echo "Script returned: $CRC_VERSION"
          if [[ $CRC_VERSION == No* ]] || [[ $CRC_VERSION == Error* ]]; then
            echo "[ERROR] The requested OpenShift version (${{ inputs.desiredOCPVersion }}) is not supported or no matching CRC release was found." >&2
            echo "Details: $CRC_VERSION" >&2
            echo "Please choose a supported OCP version (e.g., 4.17 or above) or check https://github.com/crc-org/crc/releases for available versions." >&2
            exit 1
          fi
          # If script returns 'latest' due to API issues, use latest
          if [[ $CRC_VERSION == "latest" ]]; then
            echo "Using latest CRC version due to API fallback"
          fi
          echo "crc_version=$CRC_VERSION" | tee "$GITHUB_OUTPUT"
        fi

    - name: Download and Install OpenShift Local Binary
      shell: bash
      run: |
        curl -L -o crc.tar.xz "https://mirror.openshift.com/pub/openshift-v4/clients/crc/${{ steps.set_crc_version.outputs.crc_version }}/crc-linux-amd64.tar.xz"
        tar -xvf crc.tar.xz
        sudo mv crc-linux-*/crc /usr/local/bin

    - name: CRC version lookup from crc
      shell: bash
      run: |
        crc version
        echo $PATH
        VERSION_NUMBER=$(crc version | grep CRC | awk '{ print $3 }')
        echo $VERSION_NUMBER
        echo $(crc version | grep CRC | awk '{ print $3 }')
        echo "version_number=$(crc version | grep CRC | awk '{ print $3 }')" | tee "${GITHUB_OUTPUT}"
      id: crc_version_lookup

    - name: OCP version lookup from crc
      shell: bash
      run: |
        crc version
        echo $(crc version | grep OpenShift | awk '{ print $3 }')
        echo "ocp_version=$(crc version | grep OpenShift | awk '{ print $3 }')" | tee "${GITHUB_OUTPUT}"
      id: ocp_version_lookup

    - name: Restore CRC bundles from the cache
      uses: actions/cache/restore@v4
      if: ${{ inputs.bundleCache == 'true' }}
      id: restore-cache
      with:
        path: /home/runner/.crc/bundletmp
        key: ${{ runner.os }}-${{ runner.arch }}-crc-cache-${{ steps.crc_version_lookup.outputs.version_number }}

    - name: Copy the bundletmp to actual folder if cache hit
      if: steps.restore-cache.outputs.cache-hit == 'true'
      shell: bash
      run: |
        mkdir -p /home/runner/.crc/cache
        cp -r /home/runner/.crc/bundletmp/* /home/runner/.crc/cache/

    - name: Free Disk Space (Ubuntu)
      uses: jlumbroso/free-disk-space@main
      with:
        tool-cache: false
        large-packages: true
        android: true
        dotnet: true
        haskell: true
        docker-images: true
        swap-storage: true
      continue-on-error: true

    - name: Install dependencies for specific Ubuntu versions
      shell: bash
      run: |
        UBUNTU_VERSION=$(lsb_release -rs)
        echo "Detected Ubuntu version: $UBUNTU_VERSION"
        if [[ "$UBUNTU_VERSION" == "22.04" ]]; then
          echo "Installing specific dependencies for Ubuntu 22.04"
          sudo apt-get install -y qemu
        elif [[ "$UBUNTU_VERSION" == "24.04" ]]; then
          echo "Installing specific dependencies for Ubuntu 24.04"
          sudo apt-get update
          sudo apt-get install -y virtiofsd libvirt-daemon-system libvirt-daemon-driver-qemu
          if systemctl list-unit-files | grep -q virtqemud.socket; then
            sudo systemctl enable virtqemud.socket
            sudo systemctl start virtqemud.socket
          else
            echo "virtqemud.socket unit file does not exist. Skipping enable/start steps."
          fi
        elif [[ "$UBUNTU_VERSION" == "20.04" ]]; then
          echo "Upgrading packages for Ubuntu 20.04"
          sudo apt-get upgrade -y
        else
          echo "No specific dependencies for Ubuntu version $UBUNTU_VERSION"
        fi

    - name: Enable KVM group perms
      shell: bash
      run: |
        echo 'KERNEL=="kvm", GROUP="kvm", MODE="0666", OPTIONS+="static_node=kvm"' | sudo tee /etc/udev/rules.d/99-kvm4all.rules
        sudo udevadm control --reload-rules
        sudo udevadm trigger --name-match=kvm
        sudo apt-get update
        sudo apt-get install -y libvirt-clients libvirt-daemon-system libvirt-daemon virtinst bridge-utils qemu-system-x86
        sudo usermod -a -G kvm,libvirt $USER
        sudo adduser `id -un` libvirt

    # If there is no /etc/docker/daemon.json, create it.
    - name: Create /etc/docker/daemon.json
      shell: bash
      run: |
        if [ ! -f /etc/docker/daemon.json ]; then
          echo "{}" | sudo tee /etc/docker/daemon.json
        fi

    # Restart docker using /mnt/docker-storage (sdb) instead of /var/lib/docker (sda).
    # This step needs to be done right after the partner repo's bootstrap scripts, as they
    # overwrite the docker's daemon.json.
    - name: Make docker to use /mnt (sdb) for storage
      shell: bash
      run: |
        df -h
        lsblk
        sudo mkdir /mnt/docker-storage
        sudo jq '.  +={"data-root" : "/mnt/docker-storage"}' < /etc/docker/daemon.json > /tmp/docker-daemon.json
        sudo cp /tmp/docker-daemon.json /etc/docker/daemon.json
        cat /etc/docker/daemon.json
        sudo systemctl restart docker
        sudo ls -la /mnt/docker-storage

    - name: reload the terminal to load the libvirt group
      shell: bash
      run: |
        sudo -E bash -c 'exec su -l '$USER

    - name: Check if user is part of libvirt group
      shell: bash
      run: |
        groups
        sudo usermod -a -G libvirt $USER
        groups
      
    - name: Write the pull secret to json file
      shell: bash
      run: |
        echo ${{ inputs.ocpPullSecret }} > pull-secret.json

    - name: Prompt the user if bundleCache is false
      if: ${{ inputs.bundleCache == false }}
      shell: bash
      run: echo "Skipping cache restore due to bundleCache being false"

    - name: Start OpenShift Local
      shell: bash
      run: |
        crc config set cpus ${{ inputs.crcCpu }}
        crc config set memory ${{ inputs.crcMemory }}
        crc config set disk-size ${{ inputs.crcDiskSize }}
        crc config set consent-telemetry ${{ inputs.enableTelemetry }}
        crc config set network-mode user

    - name: Run setup
      shell: bash
      run: |
        sudo -su $USER crc setup --log-level debug --show-progressbars
        sudo -su $USER crc start --pull-secret-file pull-secret.json --log-level debug

    - name: Move the .crcbundle files to another temporary folder
      shell: bash
      run: |
        mkdir -p /home/runner/.crc/bundletmp
        mv /home/runner/.crc/cache/*.crcbundle /home/runner/.crc/bundletmp/

    - name: Cache the crc bundles using github actions cache
      uses: actions/cache/save@v4
      if: ${{ inputs.bundleCache == 'true' && steps.restore-cache.outputs.cache-hit != 'true' }}
      with:
        path: /home/runner/.crc/bundletmp
        key: ${{ steps.restore-cache.outputs.cache-primary-key }}

    - name: Remove the bundle to save space
      shell: bash
      run: |
        rm -rf /home/runner/.crc/bundletmp

    - name: Print the disk statistics
      shell: bash
      run: |
        df -h

    - name: Bootstrap the runner with kubectl and oc clients
      shell: bash
      run: |
        sudo ${{ github.action_path }}/scripts/install-oc-tools.sh --latest ${{ steps.ocp_version_lookup.outputs.ocp_version }}

    - name: Wait until node is Ready state
      shell: bash
      run: |
        # Wait for cluster to be ready and accessible
        echo "Waiting for cluster to be accessible..."
        while ! oc get nodes --request-timeout='30s' &>/dev/null; do
          echo "Cluster not yet accessible, waiting..."
          sleep 10
        done
        
        # Wait for the node to be in Ready state
        while [[ $(oc get nodes --request-timeout='30s' -o json | jq -r '.items[] | select(.metadata.name=="api.crc.testing") | .status.conditions[] | select(.reason=="KubeletReady") | .status') == "False" ]]; do
          echo "Waiting for node to be in Ready state"
          sleep 5
        done

    - name: Scale down OpenShift Console components to save CPU
      shell: bash
      run: |
        oc scale --replicas=0 deployment.apps/console -n openshift-console || true
        oc scale --replicas=0 deployment.apps/downloads -n openshift-console || true
        oc scale --replicas=0 deployment.apps/console-operator -n openshift-console || true

    - name: Set the adm policy
      shell: bash
      run: |
        oc adm policy add-scc-to-user privileged user
        oc adm policy add-scc-to-group privileged system:authenticated

    - name: Wait for operators to be available
      if: ${{ inputs.waitForOperatorsReady == 'true' }}
      shell: bash
      run: ${{ github.action_path }}/scripts/wait-for-operators.sh
